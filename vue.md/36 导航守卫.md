### 36 导航守卫

> - “导航”表示路由正在发生改变
>
> - vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航
>
> - 有多种机会植入路由导航过程中：全局的, 单个路由独享的, 或者组件级的
>
>   
>

##### 36.1 全局守卫

> 可以使用`router.beforeEach`注册一个全局前置守卫
>
> ![image-20200217195541841](..\images\image-20200217195541841.png)
>
> 当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 等待中。
>
> 每个守卫方法接收三个参数：
>
> 1. to: Route: 即将要进入的目标 路由对象
> 2. from: Route: 当前导航正要离开的路由
> 3. next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。
>
> 1. next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)
> 2. next(false): 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。
> 3. next('/') 或者 next({ path: '/' }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: 'home' 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项
> 4. next(error): 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。
>
> 确保要调用 next 方法，否则钩子就不会被 resolved
>
> 不执行next()方法时 >>>
>
> ![image-20200218143238768](..\images\image-20200218143238768.png)
>
> 接收的参数已经改变了 >>>
>
> ![image-20200218143331883](..\images\image-20200218143331883.png)
>
> 但是实际上没有跳转 >>> 还是在根目录
>
> .![image-20200218143415922](..\images\image-20200218143415922.png)
>
> 执行next()方法后 >>>
>
> ![image-20200218143551410](..\images\image-20200218143551410.png)
>
> 才可以跳转 >>>
>
> ![image-20200218143617466](..\images\image-20200218143617466.png)

##### 36.2 路由独享的守卫

> 我们可以针对每个路由配置单独设置一个路由守卫
>
> `beforeEnter : ( to,from,next ) => { }`
>
> 不使用next()时 >>>
>
> ![image-20200218145109722](..\images\image-20200218145109722.png)
>
> 点击aa组件 >>> 能输出 , 但是无法跳转
>
> ![image-20200218145154540](..\images\image-20200218145154540.png)
>
> 加上next() >>>
>
> ![image-20200218145449117](..\images\image-20200218145449117.png)
>
> 现在可以正常跳转 >>>
>
> ![image-20200218145509815](..\images\image-20200218145509815.png)

##### 36.3 组件内的守卫

> ![image-20200218151218157](..\images\image-20200218151218157.png)
>
> - beforeRouteEnter 守卫 不能 访问 this，因为守卫在导航确认前被调用,因此即将登场的新组件还没被创建。
> - 不过，你可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。
>
> ![image-20200218151402256](..\images\image-20200218151402256.png)
>
> 注意 `beforeRouteEnter` 是支持给 `next` 传递回调的唯一守卫。对于 `beforeRouteUpdate` 和 `beforeRouteLeave` 来说，`this` 已经可用了，所以不支持传递回调，因为没有必要了
>
> 离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 next(false) 来取消 >>>
>
> ![image-20200218151732811](..\images\image-20200218151732811.png)
>
> 但是对于用户想要关闭网页啥的, 就没辙了

##### 36.4 完整的导航解析流程

> 1. 导航被触发。
> 2. 在失活的组件里调用离开守卫。
> 3. 调用全局的 beforeEach 守卫。
> 4. 在重用的组件里调用 beforeRouteUpdate 守卫 
> 5. 在路由配置里调用 beforeEnter。
> 6. 解析异步路由组件。
> 7. 在被激活的组件里调用 beforeRouteEnter。
> 8. 调用全局的 beforeResolve 守卫 (2.5+)。
> 9. 导航被确认。
> 10. 调用全局的 afterEach 钩子。
> 11. 触发 DOM 更新。
> 12. 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。

