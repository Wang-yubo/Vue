### 32 路由

##### 32.1 什么是路由

> - 这里的路由并不是指我们平时所说的硬件路由器，这里的路由就是SPA（single page application）的路径管理器。vue的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。
> - 传统的页面应用，是用一些超链接来实现页面切换和跳转的。在vue-router单页面应用中，则是路径之间的切换，也就是组件的切换。路由模块的本质 就是建立起url和页面之间的映射关系。
> - 至于我们为啥不能用a标签，这是因为用Vue做的都是单页应用（当你的项目准备打包时，运行npm run build时，就会生成dist文件夹，这里面只有静态资源和一个index.html页面），所以你写的标签是不起作用的，你必须使用vue-router来进行管理。

##### 32.2 路由的简易实现

> HTML部分 >>>
>
> ![image-20200215173823027](..\images\image-20200215173823027.png)
>
> script 部分 >>>
>
> ![image-20200215173949706](..\images\image-20200215173949706.png)
>
> 注意第二步这里 `routes` 这个单词只能是 `routes`
>
> ![image-20200215174001915](..\images\image-20200215174001915.png)
>
> ![image-20200215174016785](..\images\image-20200215174016785.png)
>
> 网页效果 >>>
>
> ![image-20200215174042045](..\images\image-20200215174042045.png)

##### 32.3 vue-router的实现原理之hash模式

> 单页面应用(SPA)的核心之一是: 更新视图而不重新请求页面;
>
> vue-router在实现单页面前端路由时，提供了两种方式：Hash模式和History模式；根据mode参数来决定采用哪一种方式。
>
> ![image-20200216142158533](..\images\image-20200216142158533.png)
>
> vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。hash（#）是URL 的锚点，代表的是网页中的一个位置，单单改变#后的部分，浏览器只会滚动到相应位置，不会重新加载网页，也就是说hash 出现在 URL 中，但不会被包含在 http 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面；
>
> ![image-20200216142138743](..\images\image-20200216142138743.png)
>
> hash 模式的原理是 onhashchange 事件(监测hash值变化)，可以在 window 对象上监听这个事件。

##### 32.4 vue-router的实现原理之history模式

> 由于hash模式会在url中自带#，如果不想要很丑的 hash，我们可以用路由的 history 模式，只需要在配置路由规则时，加入"mode: 'history’”
>
> 这种模式充分利用了html5 history中新增的 pushState() 和 replaceState() 方法。这两个方法应用于浏览器记录栈，在当前已有的 back、forward、go 基础之上，它们提供了对历史记录修改的功能。只是当它们执行修改时，虽然改变了当前的 URL ，但浏览器不会立即向后端发送请求。
>
> 回顾一下`history`对象 >>>
>
> history 对象保存着用户上网的历史记录，从窗口被打开的那一刻算起。因为history 是window对象的属性，因此每个浏览器窗口、每个标签页乃至每个框架，都有自己的history 对象与特定的window 对象关联。出于安全方面的考虑，开发人员无法得知用户浏览过的URL(可以想象一下如果允许的话或发生什么事情)。
>
> 不过，借由用户访问过的页面列表，同样可以在不知道实际URL 的情况下实现后退和前进
>
> ```js
> //后退一页
> history.go(-1);
> //前进一页
> history.go(1);
> //前进两页
> history.go(2);
> ```
>
> 也可以给go()方法传递一个字符串参数，此时浏览器会跳转到历史记录中包含该字符串的第一个位置——可能后退，也可能前进，具体要看哪个位置最近。如果历史记录中不包含该字符串，那么这个方法什么也不做，例如：
>
> ```js
> //跳转到最近的wrox.com 页面
> history.go("wrox.com");
> //跳转到最近的nczonline.net 页面
> history.go("nczonline.net");
> ```
>
> 另外，还可以使用两个简写方法back()和forward()来代替go()。顾名思义，这两个方法可以模仿浏览器的“后退”和“前进”按钮

##### 32.5 router-link的标签自定义

> ![image-20200216143218568](..\images\image-20200216143218568.png)
>
> 此时的router-link标签默认解析为<a>标签 >>> 可是<a>标签使用起来既不美观又有限制
>
> ![image-20200216143343745](..\images\image-20200216143343745.png)
>
> vue给router-link设置了tag属性 , 可以指定渲染后的目标标签 >>>
>
> ![image-20200216143654847](..\images\image-20200216143654847.png)
>
> 现在的效果 >>>
>
> ![image-20200216143717419](..\images\image-20200216143717419.png)
>
> ![image-20200216143741769](..\images\image-20200216143741769.png)
>
> 我们可以发现 , 在被激活的路由元素中 , 出现了两个很长的类名 , 这两个类名就表示该元素被激活了 , 但是由于太长了不方便使用 , 我们也可以对他进行修改 
>
> 为了好看一点 >>> 引用一下layui
>
> ```html
> <link rel="stylesheet" href="src/layui-v2.5.6/layui/css/layui.css">
> ```
>
> 在第三步中修改属性 >>>
>
> ![image-20200216151910876](..\images\image-20200216151910876.png)
>
> 被激活元素的效果 >>>
>
> ![image-20200216152002292](..\images\image-20200216152002292.png)
>
> 后一个类名被改变 >>>
>
> ![image-20200216152030717](..\images\image-20200216152030717.png)
>
> 添加linkExactActiveClass属性 >>>
>
> ![image-20200216154418987](..\images\image-20200216154418987.png)
>
> 网页效果 >>> 
>
> ![image-20200216154602090](..\images\image-20200216154602090.png)
>
> router-link-exact-active 是精确匹配规则，即只有当前点击router被匹配
>
> router-link-active 默认是全包含匹配规则，即path名全包含在当前router path名开头的router也会被匹配到。

