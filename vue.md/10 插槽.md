### 10. 插槽

##### 10.1 插槽的基本用法

> Vue实现了一套内容发布的API, 这套API的设计灵感源自Web Components规范草案, 将<slot>元素作为承载分发内容的出口

```html
 <div id="app">
        <child>王雨波大帅比</child>
    </div>
    <template id="child">
        <div>
            <ul>
                <slot></slot>
                <li>1</li>
                <li>2</li>
                <li>3</li>
                <slot></slot>
            </ul>
        </div>
    </template>
```

![image-20200121173322715](F:\learn Vue\images\image-20200121173322715.png)

> 当组件渲染的时候, <slot></slot>将会被替换为我们自己已经在模板标签里面写的字.插槽内可以包含任何模板代码, 包括HTML

> 如果<child>没有包含一个<slot>元素, 则该组件起始标签和结束标签之间的任何内容都会被抛弃, 也就是说模板里的内容如果没有<slot>元素来接收替换, 那么模板里的内容不会渲染在任何地方

##### 10.2插槽的后备内容

> 有时为一个插槽设置具体的后备 (也就是默认的) 内容是很有用的，它只会在没有提供内容的时候被渲染

<img src="F:\learn Vue\images\image-20200121193151050.png" alt="image-20200121193151050" style="zoom:80%;" />

![image-20200121193213000](F:\learn Vue\images\image-20200121193213000.png)

> 结果就是有后备内容的插槽渲染了, 没有后备内容的插槽被抛弃了

##### 10.3 插槽的编译作用域

```js
let vm = new Vue({
            el: '#app',
            components: {
                child,
            },
            data: {
                msg: '父组件的数据'
            }
        })
```

![image-20200121194449924](F:\learn Vue\images\image-20200121194449924.png)

> 此时的<slot>标签便用父组件中的数据来替换

![image-20200121194546740](F:\learn Vue\images\image-20200121194546740.png)

> 删掉模板, 使用后备内容时,可以使用子组件里的数据

```js
 let child = {
            template: '#child',
            data() {
                return {
                    msg: "子组件的数据",
                }
            }
        }
```

<img src="F:\learn Vue\images\image-20200121195036255.png" alt="image-20200121195036255" style="zoom:80%;" />

<img src="F:\learn Vue\images\image-20200121195057490.png" alt="image-20200121195057490" style="zoom:80%;" />

##### 10.4 具名插槽

> - 有时我们需要多个插槽 , <slot> 元素有一个特殊的特性：name。这个特性可以用来定义额外的插槽：一个不带 name 的 <slot> 出口会带有隐含的名字“default”。 
> - 在向具名插槽提供内容的时候，我们可以在一个 <template> 元素上使用 v-slot 指令，并以 v-slot 的参数的形式提供其名称：任何没有被包裹在带有 v-slot 的 <template> 中的内容都会被视为默认插槽的内容。

<img src="F:\learn Vue\images\image-20200121200917339.png" alt="image-20200121200917339" style="zoom:80%;" />

<img src="F:\learn Vue\images\image-20200121200932444.png" alt="image-20200121200932444" style="zoom:80%;" />

> 这样名字和模板就对应起来了

##### 10.5 作用域插槽

> 有时让插槽内容能够访问子组件中才有的数据是很有用的

> 使用步骤

<img src="F:\learn Vue\images\image-20200121203445846.png" alt="image-20200121203445846" style="zoom:67%;" />

> 结果: 还真拿到了~~

![image-20200121205612193](F:\前端开发\learn canvas\images\image-20200121205612193.png)

> 自定义的变量此时是对象属性

> 还可以利用结构赋值

<img src="F:\前端开发\learn canvas\images\image-20200121212311299.png" alt="image-20200121212311299" style="zoom:80%;" />

> 仍然拿到了子组件的数据

![image-20200121212351272](F:\前端开发\learn canvas\images\image-20200121212351272.png)

> 用这种方法也可以绑定多条数据

<img src="F:\前端开发\learn canvas\images\image-20200121212740417.png" alt="image-20200121212740417" style="zoom:80%;" />

> 结果没问题

![image-20200121212811442](F:\前端开发\learn canvas\images\image-20200121212811442.png)

##### 10.6 作用域插槽之独占默认插槽的缩写语法

> 当我们只有一个模板需要使用子组件的数据时,我们可以简化以上写法
>
> 可以不使用template模板

![image-20200121211330479](F:\前端开发\learn canvas\images\image-20200121211330479.png)

> - 注意事项: 
> - 默认插槽的缩写语法不能和具名插槽混用，因为它会导致作用域不明确
> - 只要出现多个插槽，请始终为所有的插槽使用完整的基于 <template> 的语法

